<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Gambling Task — Calibration + Validation + Practice + Main</title>
<style>
  :root{ --bg:#808080; --fix: rgb(166,85,34); --txt:#fff; }
  html,body{ height:100%; margin:0; background:var(--bg); font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial,sans-serif;}
  .center{ position:fixed; inset:0; display:flex; align-items:center; justify-content:center; color:var(--txt);}
  .wrap{ max-width:980px; padding:28px; line-height:1.65; outline:none; }
  h1,h2{ margin:0 0 12px 0;} h2{ font-size:24px;}
  p,li{ font-size:16px;}
  .btn{ display:inline-block; padding:.6rem 1rem; border-radius:10px; background:#1e88e5; color:#fff; text-decoration:none; cursor:pointer; margin:10px 10px 0 0; border:none; }
  .btn:disabled{ opacity:.6; cursor:not-allowed; }
  .muted{ opacity:.85; font-size:14px;}
  .fix{ font-size:28px; color:var(--fix); position:fixed; left:50%; top:50%; transform:translate(-50%,-50%); font-family:monospace;}
  .arena{ position:fixed; inset:0; display:flex; align-items:center; justify-content:center; background:var(--bg);}
  .stage{ position:relative; width:100vw; height:70vh;}
  .box{ position:absolute; top:50%; transform:translate(-50%,-50%); width:240px; height:240px; border:6px solid currentColor; border-radius:16px;
        display:flex; align-items:center; justify-content:center; font-weight:800; font-size:72px; line-height:1; user-select:none;
        box-shadow:0 0 0 1px rgba(0,0,0,.08); text-shadow:0 0 0.5px rgba(0,0,0,.15);}
  .legend{ position:fixed; left:50%; transform:translateX(-50%); bottom:32px; color:#fff; text-align:center; font-size:18px;}
  .pt{ position:fixed; width:14px; height:14px; border-radius:50%; background:#e53935; transform:translate(-50%,-50%); box-shadow:0 0 0 4px rgba(229,57,53,.25); z-index:9998;}
  #gazeDot{ position:fixed; width:10px; height:10px; border-radius:50%; background:#ff1744; opacity:.9; pointer-events:none; transform:translate(-50%,-50%); display:none; z-index:10000;}
  .grid{ display:grid; grid-template-columns:repeat(3, 120px); grid-gap:10px; justify-content:center; margin:18px 0;}
  .cell{ width:120px; height:80px; border-radius:10px; display:flex; align-items:center; justify-content:center; font-weight:700; font-size:20px;
         background:rgba(255,255,255,.15); border:2px solid rgba(255,255,255,.25);}
  .ok{ background:rgba(76,175,80,.25); border-color:rgba(76,175,80,.5);}
  .bad{ background:rgba(244,67,54,.25); border-color:rgba(244,67,54,.6);}
  .status{ position:fixed; right:12px; bottom:12px; background:rgba(0,0,0,.35); color:#fff; border-radius:10px; padding:8px 12px; font-size:13px; z-index:10001;}
  .consent-box{ background:rgba(0,0,0,.25); padding:14px 16px; border-radius:10px; margin:12px 0;}
  .note{ padding:10px 12px; background:rgba(255,255,255,.15); border-radius:8px;}
  #err{ position:fixed; left:12px; bottom:12px; max-width:50vw; background:rgba(0,0,0,.6); color:#fff; padding:10px 12px; border-radius:10px; font:12px/1.4 monospace; white-space:pre-wrap; z-index:10002; display:none;}

  /* Fullscreen guard overlay */
  #fsGuard{ position:fixed; inset:0; background:rgba(0,0,0,.7); color:#fff; display:none; align-items:center; justify-content:center; z-index:10020;}
  .guardCard{ width:min(560px,90vw); background:#222; color:#fff; border-radius:14px; padding:20px 22px; box-shadow:0 10px 30px rgba(0,0,0,.5);}
  .guardCard h3{ margin:0 0 8px 0; font-size:20px;}
</style>
</head>
<body>
<div id="gazeDot"></div>
<div id="status" class="status" style="display:none;">Preparing camera…</div>
<div id="err"></div>
<div id="app" class="center"><div class="wrap">Initializing…</div></div>

<!-- Fullscreen guard (shown if participant exits fullscreen during task) -->
<div id="fsGuard">
  <div class="guardCard">
    <h3>Fullscreen required</h3>
    <p>For data quality, please stay in fullscreen during calibration and the task.</p>
    <button class="btn" id="fsReturn">Return to fullscreen</button>
  </div>
</div>

<script>
/* ===================== Error capture ===================== */
(function(){
  const err = document.getElementById('err');
  function showErr(msg, src, line, col, e){
    err.style.display='block';
    err.textContent = '[Script Error] ' + (msg||'') + (src?('\\n@ '+src+':'+line+':'+col):'') + (e && e.stack?('\\n'+e.stack):'');
  }
  window.addEventListener('error', e => { showErr(e.message, e.filename, e.lineno, e.colno, e.error); });
  window.addEventListener('unhandledrejection', e => {
    err.style.display='block';
    err.textContent = '[Unhandled Promise] ' + (e.reason && (e.reason.stack || e.reason.message || e.reason));
  });
})();

/* ===================== Helpers & constants ===================== */
const app = document.getElementById('app');
const gazeDot = document.getElementById('gazeDot');
const statusBox = document.getElementById('status');

/* Fullscreen guard */
const fsGuard = document.getElementById('fsGuard');
const fsReturnBtn = document.getElementById('fsReturn');
let fsGuardEnabled = false;
fsReturnBtn.addEventListener('click', async ()=>{ try{ await enterFullscreen(); }catch(e){}; checkFsGuard(); });
function checkFsGuard(){
  if (fsGuardEnabled && !isFullscreen()) { fsGuard.style.display='flex'; }
  else { fsGuard.style.display='none'; }
}
document.addEventListener('fullscreenchange', checkFsGuard);

const show = html => {
  app.innerHTML = `<div class="wrap" tabindex="-1">${html}</div>`;
  const wrap = app.querySelector('.wrap');
  setTimeout(() => { try { wrap && wrap.focus({ preventScroll: true }); } catch(e){} }, 0);
};
const showCenter = html => {
  app.innerHTML = html;
  if (!app.hasAttribute('tabindex')) app.setAttribute('tabindex','-1');
  setTimeout(() => { try { app.focus({ preventScroll: true }); } catch(e){} }, 0);
};

const sleep = ms => new Promise(r=>setTimeout(r, ms));
const shuffle = a => { for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]] } return a; };
const randBetween = (a,b)=> a + Math.floor(Math.random()*(b-a+1));
const setStageBlank = on => { app.style.display = on ? 'none' : 'flex'; };

const PRACTICE_N = 5;
const N_UNIQUE   = 100;                // 100 rounds per group → 200 total
const START_ENDOWMENT = 10;
let PX_PER_DEG = 40;
const SEP_DEG = 13;
const KEY_REMIND_INTERVAL = 25;
const MID_POINT_IN_BLOCK = 50;

const offsetPx = () => Math.round(PX_PER_DEG * SEP_DEG / 2);

const BLUE  = 'rgb(53,126,179)';
const GREEN = 'rgb(61,137,69)';

const POINTS_9 = [
  [10,10],[50,10],[90,10],
  [10,50],[50,50],[90,50],
  [10,90],[50,90],[90,90]
];
const POINTS_5   = [[50,50],[10,10],[90,10],[10,90],[90,90]];
const VALIDATION_SERP = [
  [10,10],[50,10],[90,10],
  [90,50],[50,50],[10,50],
  [10,90],[50,90],[90,90]
];

const ROI = 200, REPS = 2, MIN_OK = 60;
const VAL_POINT_MS = 2500;
const MID_VAL_POINT_MS = 2500;
const SHOW_GAZE_DOT_TASK = false;

/* Prolific mappings & query */
const urlQS = new URLSearchParams(location.search);
const PROLIFIC_PID = urlQS.get('PROLIFIC_PID') || null;
const PROLIFIC_RETURN_URL = urlQS.get('RETURN_URL') || null;
function getQS(name){ return urlQS.get(name) || ''; }
function hash32(str){ let h=2166136261>>>0; for(let i=0;i<str.length;i++){ h^=str.charCodeAt(i); h=(h*16777619)>>>0;} return h; }
const PARTICIPANT_GAIN_BLUE = PROLIFIC_PID ? ((hash32(PROLIFIC_PID) & 1) === 0) : (Math.random()<0.5);
const PARTICIPANT_ACCEPTS_WITH_D = PROLIFIC_PID ? ((hash32(PROLIFIC_PID+'key') & 1) === 0) : (Math.random()<0.5);
const KEYMAP = PARTICIPANT_ACCEPTS_WITH_D
  ? {accept:'d', reject:'j', legend:'D = Accept   /   J = Reject'}
  : {accept:'j', reject:'d', legend:'J = Accept   /   D = Reject'};
const DECISION_KEYS = new Set(['d','j','D','J']);
function keyLegendHTML(showIt){ return showIt ? `<div class="legend"><b>${KEYMAP.legend}</b></div>` : ''; }

/* Retrieve previous pixel-per-degree calibration */
try{
  const saved = parseFloat(localStorage.getItem('px_per_deg'));
  if (!isNaN(saved) && saved > 0) { PX_PER_DEG = saved; }
}catch(e){}

/* ===================== Fullscreen & zoom check ===================== */
function checkZoomAndSize(){
  const scale = (window.visualViewport && window.visualViewport.scale) ? window.visualViewport.scale : 1;
  const tooSmall = (window.innerWidth < 1024 || window.innerHeight < 650);
  let warn = '';
  if (Math.abs(scale - 1) > 0.03){
    const key = navigator.platform && navigator.platform.includes('Mac') ? 'Cmd+0' : 'Ctrl+0';
    warn += `Your browser zoom is not 100%. Press ${key} to reset.\n`;
  }
  if (tooSmall){
    warn += 'Window is too small (≥ 1024×650 recommended). Please maximize or use a larger display.\n';
  }
  return warn;
}
function isFullscreen(){
  return !!(document.fullscreenElement ||
            document.webkitFullscreenElement ||
            document.mozFullScreenElement ||
            document.msFullscreenElement);
}
async function enterFullscreen(){
  try{
    const el = document.documentElement;
    const req = el.requestFullscreen || el.webkitRequestFullscreen || el.mozRequestFullScreen || el.msRequestFullscreen;
    if (req) {
      const ret = req.call(el);
      if (ret && typeof ret.then === 'function') { await ret; }
    }
    if (screen.orientation && screen.orientation.lock) {
      try { await screen.orientation.lock('landscape'); } catch(e) {}
    }
  }catch(e){ console.warn('enterFullscreen error:', e); }
}

/* ===================== Trial set generation ===================== */
function genUnique(n=100){
  const s=new Set(), arr=[];
  while(arr.length<n){
    const g=1+Math.floor(Math.random()*10);
    const l=1+Math.floor(Math.random()*10);
    const k=`${g}_${l}`;
    if(!s.has(k)){ s.add(k); arr.push({gain:g, loss:l}); }
  }
  return arr;
}
const practiceSet = genUnique(PRACTICE_N);
const baseSet     = genUnique(N_UNIQUE);
const block1      = shuffle(baseSet.map(x=>({...x})));
const block2      = shuffle(baseSet.map(x=>({...x})));

/* ===================== WebGazer dynamic loading ===================== */
let WG_READY = false;
async function loadScript(url){
  return new Promise((res, rej)=>{
    const s = document.createElement('script');
    s.src = url; s.async = true; s.onload = ()=>res(url); s.onerror = ()=>rej(new Error('Failed to load: '+url));
    document.head.appendChild(s);
  });
}
async function ensureWebgazer(){
  const sources = [
    'https://webgazer.cs.brown.edu/webgazer.js',
    'https://unpkg.com/webgazer@^2/dist/webgazer.js'
  ];
  let lastErr=null;
  for(const u of sources){
    try{ await loadScript(u); if(window.webgazer){ WG_READY=true; return u; } }
    catch(e){ lastErr=e; }
  }
  throw lastErr || new Error('Unable to load webgazer.js');
}

/* ===================== WebGazer wrapping & camera warmup ===================== */
let previewTimer = null, previewKeepAlive=null;
function ensurePreviewVisible(){
  const vg = document.getElementById('webgazerVideoContainer');
  if (vg){
    vg.style.display='block'; vg.style.visibility='visible';
    vg.style.position='fixed'; vg.style.left='12px'; vg.style.top='12px';
    vg.style.zIndex=10000; vg.style.pointerEvents='none';
    vg.style.width = '160px'; vg.style.height = 'auto';
    vg.style.background = 'transparent';
  }
}
function movePreviewToCorner(){ ensurePreviewVisible(); }
async function initWebgazer(){
  try{ webgazer.setRegression('ridge'); webgazer.setTracker('TFFacemesh'); }catch(e){}
  if (webgazer.params){
    webgazer.params.showVideoPreview = true;
    webgazer.params.showFaceFeedbackBox = true;
  }
  webgazer.showPredictionPoints(false);
  await webgazer.begin();
  movePreviewToCorner();
}
function startGazePreview(){
  if (!WG_READY) return;
  webgazer.showVideoPreview(true);
  movePreviewToCorner();
  statusBox.style.display='block';
  gazeDot.style.display='block';
  if (previewTimer) clearInterval(previewTimer);
  previewTimer = setInterval(async ()=>{
    const p=await webgazer.getCurrentPrediction();
    if (p){ gazeDot.style.left=p.x+'px'; gazeDot.style.top=p.y+'px'; statusBox.textContent='Tracking OK ✓'; }
    else { statusBox.textContent='Camera is preparing… this can take a few seconds.'; }
  },33);
  if (previewKeepAlive) clearInterval(previewKeepAlive);
  previewKeepAlive = setInterval(()=>ensurePreviewVisible(), 500);
}
function stopGazePreview(){
  if (previewTimer) { clearInterval(previewTimer); previewTimer=null; }
  if (previewKeepAlive) { clearInterval(previewKeepAlive); previewKeepAlive=null; }
  gazeDot.style.display='none'; statusBox.style.display='none';
  webgazer.showVideoPreview(false);
}
async function waitForPrediction(waitMs=10000){
  const t0=performance.now(); while(performance.now()-t0<waitMs){ const p=await webgazer.getCurrentPrediction(); if(p) return true; await sleep(100); } return false;
}

/* Camera warmup WITHOUT progress bar — only a short notice */
async function warmupCameraAndPreview({msg='Camera is preparing… this can take a few seconds.', waitMs=10000}={}){
  // show a small notice in the main area (English only); preview sits top-left
  show(`<h2>Camera setup</h2><p class="muted">${msg}</p>`);
  startGazePreview(); ensurePreviewVisible();
  const ok = await waitForPrediction(waitMs);
  // keep going either way
  stopGazePreview();
  return ok;
}

/* ===================== Wait for Space ===================== */
function awaitSpace(){
  const target = app.querySelector('.wrap') || app;
  if (target && !target.hasAttribute('tabindex')) target.setAttribute('tabindex','-1');
  setTimeout(() => { try { (target || document.body).focus({ preventScroll:true }); } catch(e){} }, 0);

  return new Promise(resolve=>{
    function onKey(e){
      const isSpace = (e.code === 'Space') || (e.key === ' ') || (e.keyCode === 32);
      const tag = (e.target && e.target.tagName) ? e.target.tagName : '';
      const isTypingTarget = ['INPUT','TEXTAREA','SELECT'].includes(tag);
      if (isSpace && !isTypingTarget){
        e.preventDefault(); cleanup(); resolve();
      }
    }
    function cleanup(){
      window.removeEventListener('keydown', onKey, true);
      document.removeEventListener('keydown', onKey, true);
    }
    window.addEventListener('keydown', onKey, true);
    document.addEventListener('keydown', onKey, true);
  });
}

/* ===================== Pages before practice ===================== */
async function showWelcome(){
  return await new Promise((resolve)=>{
    show(`
      <h2>Welcome</h2>
      <p class="muted">Click the button below to <b>enter fullscreen</b> and continue.</p>
      <button class="btn" id="btnNext">Enter fullscreen and continue</button>
    `);
    document.getElementById('btnNext').onclick = async ()=>{
      const warn = checkZoomAndSize(); if (warn) alert(warn);
      try { await enterFullscreen(); } catch(e) {}
      resolve();
    };
  });
}

let consent_record = null;
async function showConsent(){
  return await new Promise((resolve)=>{
    show(`
      <h2>Informed Consent (Online Decision Task & Gaze Estimation)</h2>
      <p>You will complete a keyboard-based decision task while a <b>local</b> webcam-based estimator infers your gaze. We <b>do not store</b> audio/video. Only de-identified data (gaze points, key presses, RTs) are saved.</p>
      <div class="consent-box">
        <label><input type="checkbox" id="c1"> I am 18+ years old, have read and understood the above, and voluntarily agree to participate.</label><br/>
        <label><input type="checkbox" id="c2"> I understand and agree that webcam images are used locally for gaze estimation; the researchers do not save audio/video.</label>
      </div>
      <div style="display:flex; gap:10px; flex-wrap:wrap;">
        <button class="btn" id="agree" disabled>I agree, continue</button>
        <button class="btn" id="decline">I do not agree — Exit</button>
      </div>
    `);
    const c1 = document.getElementById('c1');
    const c2 = document.getElementById('c2');
    const agree = document.getElementById('agree');
    function update(){ agree.disabled = !(c1.checked && c2.checked); }
    c1.onchange = c2.onchange = update; update();

    agree.onclick = ()=>{
      consent_record = { accepted:true, t:new Date().toISOString(), prolific_pid: PROLIFIC_PID };
      resolve('agreed');
    };
    document.getElementById('decline').onclick = ()=>{
      consent_record = { accepted:false, t:new Date().toISOString(), prolific_pid: PROLIFIC_PID };
      resolve('declined');
    };
  });
}

async function runScreenScaleCalibration(){
  show(`
    <h2>Screen Calibration</h2>
    <p>Use a standard bank/ID card (width <b>85.6 mm</b>) to match the gray rectangle.</p>
    <div style="display:flex;gap:24px;align-items:center;flex-wrap:wrap;margin:14px 0;">
      <div>
        <div id="cardBox" style="width:240px;height:135px;background:rgba(255,255,255,.12);border:2px dashed rgba(255,255,255,.4);border-radius:8px;"></div>
        <div style="margin-top:8px;">
          Width: <input id="cardRange" type="range" min="160" max="420" value="240" style="width:260px;vertical-align:middle;">
          <span id="pxLabel">240 px</span>
        </div>
        <div class="muted">Calibrate using <b>width only</b> (85.6 mm).</div>
      </div>
      <div style="min-width:220px;">
        <label>Viewing distance (cm):
          <input id="dist" type="number" min="40" max="90" value="60" style="width:80px;"/>
        </label>
        <div class="muted" style="margin-top:6px;">
          Recommended <b>40–60 cm</b>; if unsure, enter <b>50</b>.
        </div>
        <div id="previewSep" class="muted" style="margin-top:8px;"></div>
      </div>
    </div>
    <button class="btn" id="saveScale">Save calibration and continue</button>
  `);
  const cardBox=document.getElementById('cardBox');
  const range=document.getElementById('cardRange');
  const pxLabel=document.getElementById('pxLabel');
  const distInp=document.getElementById('dist');
  const prevSep=document.getElementById('previewSep');

  function updateLabels(){
    const px = +range.value;
    pxLabel.textContent = `${px} px`;
    const px_per_mm = px / 85.6;
    const d_mm = Math.max(400, Math.min(900, (+distInp.value||60)*10));
    const mm_per_deg = d_mm * Math.tan(Math.PI/180);
    const px_per_deg = px_per_mm * mm_per_deg;
    prevSep.textContent = `At current settings, a 13° center-to-center spacing ≈ ${Math.round(px_per_deg*13)} px`;
    cardBox.style.width = px + 'px';
    cardBox.style.height = Math.round(px * 53.98/85.6) + 'px';
  }
  range.oninput=updateLabels; distInp.oninput=updateLabels; updateLabels();
  await new Promise(r=>document.getElementById('saveScale').onclick=r);

  const px = +range.value;
  const px_per_mm = px / 85.6;
  const d_mm = Math.max(400, Math.min(900, (+distInp.value||60)*10));
  const mm_per_deg = d_mm * Math.tan(Math.PI/180);
  PX_PER_DEG = px_per_mm * mm_per_deg;
  try { localStorage.setItem('px_per_deg', String(PX_PER_DEG)); } catch(e){}
}

/* ===== Overview & Quiz ===== */
async function showOverview(){
  return await new Promise((resolve)=>{
    show(`
      <h2>Overview & Instructions</h2>
      <ol>
        <li><b>Eye-tracking setup:</b> 9-point calibration + 9-point validation.</li>
        <li><b>Per-round flow:</b> central cross “+” for 2–4 s → two boxes appear (Gain +$ / Loss −$), each with 50% probability → choose Accept/Reject via keyboard (no time limit).</li>
        <li><b>Practice:</b> ${PRACTICE_N} rounds (not used for payment; you may repeat if needed).</li>
        <li><b>Main session:</b> <b>200 rounds</b> total, in <b>two groups of 100</b>. In each group, after round <b>50</b> you will complete <b>5-point calibration → 5-point validation</b>; a <b>key reminder</b> appears every <b>25</b> rounds.</li>
        <li><b>Payment:</b> start with $${START_ENDOWMENT}. After finishing, one <b>main</b> round is randomly selected: if you rejected on that round, you keep $${START_ENDOWMENT}; if you accepted, a random outcome determines win/loss (added to/subtracted from the starting amount).</li>
      </ol>
      <button class="btn" id="btnNext">I understand, continue</button>
    `);
    document.getElementById('btnNext').onclick=()=>resolve('next');
  });
}

async function showComprehensionQuiz(){
  return await new Promise((resolve)=>{
    renderQuiz();
    function renderQuiz(){
      show(`
        <h2>Comprehension Check</h2>
        <p class="muted">All answers must be correct to proceed.</p>
        <ol style="margin-top:10px;">
          <li style="margin-bottom:10px;">
            What are the probabilities of the gain (+) and loss (−) outcomes on each round?
            <div>
              <label><input type="radio" name="q1" value="A"> 50% / 50%</label><br>
              <label><input type="radio" name="q1" value="B"> 100% / 0%</label><br>
              <label><input type="radio" name="q1" value="C"> 75% / 25%</label>
            </div>
          </li>
          <li style="margin-bottom:10px;">
            During the session, may you move your head freely and blink frequently?
            <div>
              <label><input type="radio" name="q2" value="A"> Yes, move freely and blink often</label><br>
              <label><input type="radio" name="q2" value="B"> No, keep your head stable and minimize blinking</label><br>
              <label><input type="radio" name="q2" value="C"> Eyes must remain closed at all times</label>
            </div>
          </li>
          <li style="margin-bottom:10px;">
            How is the final payment determined?
            <div>
              <label><input type="radio" name="q3" value="A"> One <b>main</b> round is randomly selected: if Rejected → keep $10; if Accepted → a random outcome determines win/loss relative to the $10 start</label><br>
              <label><input type="radio" name="q3" value="B"> Sum outcomes from all rounds</label><br>
              <label><input type="radio" name="q3" value="C"> Use only the practice rounds</label>
            </div>
          </li>
          <li style="margin-bottom:10px;">
            In each <b>group</b>, after which round will you complete the <b>5-point calibration & validation</b>?
            <div>
              <label><input type="radio" name="q4" value="A"> After round 25</label><br>
              <label><input type="radio" name="q4" value="B"> After round 50</label><br>
              <label><input type="radio" name="q4" value="C"> Never</label>
            </div>
          </li>
        </ol>
        <div id="quizMsg" class="muted" style="margin-top:10px;"></div>
        <div style="display:flex; gap:10px; flex-wrap:wrap;">
          <button class="btn" id="submitQuiz">Submit</button>
          <button class="btn" id="backOverview">Back to Overview</button>
        </div>
      `);

      function get(name){ const el = document.querySelector(`input[name="${name}"]:checked`); return el?el.value:null; }

      document.getElementById('submitQuiz').onclick = ()=>{
        const wrong = [];
        if(get('q1')!=='A') wrong.push('Q1');
        if(get('q2')!=='B') wrong.push('Q2');
        if(get('q3')!=='A') wrong.push('Q3');
        if(get('q4')!=='B') wrong.push('Q4');
        const msg = document.getElementById('quizMsg');
        if (wrong.length){
          msg.innerHTML = 'Incorrect items: <b>' + wrong.join(', ') + '</b>. Review the overview or adjust your answers and submit again.';
        }else{
          show('<h2>Comprehension check passed ✓</h2><button class="btn" id="goNext">Continue</button>');
          document.getElementById('goNext').onclick=()=>resolve();
        }
      };

      document.getElementById('backOverview').onclick = async ()=>{
        await showOverview();
        await showComprehensionQuiz();
        resolve();
      };
    }
  });
}

/* ===== Fullscreen fallback ===== */
async function showFullscreenStep(){
  show(`
    <h2>Fullscreen</h2>
    <p>If fullscreen did not start, click the button below to enter <b>system fullscreen</b> (Esc to exit).</p>
    <button class="btn" id="goFS">Enter fullscreen and continue</button>
  `);
  await new Promise((resolve)=>{
    document.getElementById('goFS').onclick = async ()=>{
      const warn = checkZoomAndSize(); if (warn) alert(warn);
      try { await enterFullscreen(); } catch(e) {}
      resolve();
    };
  });
}

/* ===== Calibration instruction pages ===== */
function showCalibIntro9(){
  show(`
    <h2>9-Point Calibration (each point: <b>click 2 times</b>)</h2>
    <div class="note">
      <b>Preview check:</b> keep your face centered in the top-left preview, both eyes visible, avoid strong backlight; sit 50–70 cm from the screen; browser zoom 100%.
    </div>
    <ol style="margin-top:10px;">
      <li>Red dots appear in <b>random order</b> at 9 positions (corners, mid-edges, center).</li>
      <li>On each dot, <b>click twice</b>, about <b>0.3–0.5 s</b> apart; keep your gaze on the dot while clicking.</li>
      <li>After finishing all 9 dots, you will see a <b>validation instruction</b>. Click to start validation.</li>
    </ol>
    <button class="btn" id="calStart9">Start 9-point calibration</button>
  `);
}

/* 9-point validation intro (click to start) */
function showValidationIntro9(){
  show(`
    <h2>9-Point Validation</h2>
    <div class="note">
      Please keep your head stable and look at each red dot as it appears. No clicking needed during validation.
    </div>
    <button class="btn" id="valStart9">Start 9-point validation</button>
  `);
}

function showCalibIntro5First(){
  show(`
    <h2>5-Point Calibration (each point: <b>click 2 times</b>)</h2>
    <div class="note">
      We will recalibrate to ensure tracking quality. Click <b>twice</b> on each red dot (~0.3–0.5 s apart) while keeping your gaze on it.
      <br>After finishing, a 5-point validation will <b>start automatically</b>.
    </div>
    <button class="btn" id="calStart5">Start 5-point calibration</button>
  `);
}

function showCalibIntro5Retry(){
  show(`
    <h2>5-Point Calibration (retry)</h2>
    <div class="note">
      The previous 5-point validation did not pass. Please calibrate again (click each dot twice). Validation will start automatically afterward.
    </div>
    <button class="btn" id="calRetry5">Start 5-point calibration again</button>
  `);
}

/* ===================== 9-point calibration & validation ===================== */
async function calibrateNinePointsMouse(){
  setStageBlank(true);
  const seq = shuffle(POINTS_9.slice());
  await new Promise(resolve=>{
    let idx=0, count=0, dot=null;
    function place(){
      const [px,py] = seq[idx];
      const x=innerWidth*px/100, y=innerHeight*py/100;
      dot=document.createElement('div'); dot.className='pt'; dot.style.left=x+'px'; dot.style.top=y+'px';
      function clickOnce(){
        count++;
        try{
          if (webgazer.recordScreenPosition) webgazer.recordScreenPosition(x,y,'click');
          else if (webgazer.addCalibrationPoint) webgazer.addCalibrationPoint(x,y);
        }catch(e){}
        dot.style.boxShadow=`0 0 0 ${4+count*2}px rgba(229,57,53,.25)`;
        if(count>=REPS){ dot.removeEventListener('click', clickOnce); dot.remove(); count=0; idx++; if(idx<seq.length) place(); else resolve(); }
      }
      dot.addEventListener('click', clickOnce);
      document.body.appendChild(dot);
    } place();
  });
  setStageBlank(false);
}

async function runNineValidation(){
  setStageBlank(true);
  let acc=[];
  for(const [px,py] of VALIDATION_SERP){
    const x=innerWidth*px/100, y=innerHeight*py/100;
    const dot=document.createElement('div'); dot.className='pt'; dot.style.left=x+'px'; dot.style.top=y+'px';
    document.body.appendChild(dot);
    let inR=0,total=0; const t0=performance.now();
    while(performance.now()-t0 < VAL_POINT_MS){
      const p=await webgazer.getCurrentPrediction();
      if(p){ total++; const dx=p.x-x, dy=p.y-y; if(dx*dx+dy*dy <= ROI*ROI) inR++; }
      await sleep(16);
    }
    acc.push(total? Math.round(100*inR/total) : 0);
    dot.remove(); await sleep(120);
  }
  setStageBlank(false);
  return acc;
}

async function showValidationOutcomeAndMaybeLoop9(acc){
  const mean = Math.round(acc.reduce((a,b)=>a+b,0)/acc.length);
  const cells = acc.map(p=>`<div class="cell ${p>=MIN_OK?'ok':'bad'}">${p}%</div>`);
  const failed = acc.some(p=>p<MIN_OK);
  show(`
    <h2>Validation Results</h2>
    <p>Per-point hit rate (threshold: ${MIN_OK}%):</p>
    <div class="grid">${cells.slice(0,3).join('')}${cells.slice(3,6).join('')}${cells.slice(6,9).join('')}</div>
    <p>Mean hit rate across 9 points: <b>${mean}%</b></p>
    <button class="btn" id="btnNext">${failed ? 'Not passed: redo 9-point calibration' : 'Passed: continue'}</button>
  `);
  await new Promise(r=>document.getElementById('btnNext').onclick=r);
  if (failed){
    showCalibIntro9();
    await new Promise(r=>document.getElementById('calStart9').onclick=r);
    await warmupCameraAndPreview();
    await calibrateNinePointsMouse();

    showValidationIntro9();
    await new Promise(r=>document.getElementById('valStart9').onclick=r);

    await warmupCameraAndPreview();
    const acc2 = await runNineValidation();
    await showValidationOutcomeAndMaybeLoop9(acc2);
  }
}

async function calibrationFlow(){
  // Enable fullscreen guard from here on
  fsGuardEnabled = true; checkFsGuard();

  showCalibIntro9();
  await new Promise(r=>document.getElementById('calStart9').onclick=r);

  await warmupCameraAndPreview();
  await calibrateNinePointsMouse();

  showValidationIntro9();
  await new Promise(r=>document.getElementById('valStart9').onclick=r);

  await warmupCameraAndPreview();
  const acc = await runNineValidation();
  await showValidationOutcomeAndMaybeLoop9(acc);
}

/* ======= Mid-session: 5-point calibration → validation ======= */
function showMidWhyIntro(){
  show(`
    <h2>Recalibration</h2>
    <div class="note">
      You have completed about <b>50</b> rounds in this group. To ensure <b>data quality</b> and <b>tracking stability</b>, we will run a <b>5-point calibration</b> (click twice per dot). Validation will start automatically after that. If not passed, you will recalibrate again until passed.
    </div>
    <p class="muted">Press Space to continue.</p>
  `);
}

async function calibrateFivePointsMouse(){
  setStageBlank(true);
  const seq = POINTS_5.slice();
  await new Promise(resolve=>{
    let idx=0, count=0, dot=null;
    function place(){
      const [px,py] = seq[idx];
      const x=innerWidth*px/100, y=innerHeight*py/100;
      dot=document.createElement('div'); dot.className='pt'; dot.style.left=x+'px'; dot.style.top=y+'px';
      function clickOnce(){
        count++;
        try{
          if (webgazer.recordScreenPosition) webgazer.recordScreenPosition(x,y,'click');
          else if (webgazer.addCalibrationPoint) webgazer.addCalibrationPoint(x,y);
        }catch(e){}
        dot.style.boxShadow=`0 0 0 ${4+count*2}px rgba(229,57,53,.25)`;
        if(count>=REPS){ dot.removeEventListener('click', clickOnce); dot.remove(); count=0; idx++; if(idx<seq.length) place(); else resolve(); }
      }
      dot.addEventListener('click', clickOnce);
      document.body.appendChild(dot);
    } place();
  });
  setStageBlank(false);
}

async function runFiveValidation(){
  setStageBlank(true);
  let acc=[];
  for(const [px,py] of POINTS_5){
    const x=innerWidth*px/100, y=innerHeight*py/100;
    const dot=document.createElement('div'); dot.className='pt'; dot.style.left=x+'px'; dot.style.top=y+'px';
    document.body.appendChild(dot);

    let inR=0,total=0; const t0=performance.now();
    while(performance.now()-t0 < MID_VAL_POINT_MS){
      const p=await webgazer.getCurrentPrediction();
      if(p){ total++; const dx=p.x-x, dy=p.y-y; if(dx*dx+dy*dy <= ROI*ROI) inR++; }
      await sleep(16);
    }
    acc.push(total? Math.round(100*inR/total) : 0);
    dot.remove(); await sleep(120);
  }
  setStageBlank(false);

  const mean   = Math.round(acc.reduce((a,b)=>a+b,0)/acc.length);
  const passAll = acc.every(p=>p >= MIN_OK);
  const cells  = acc.map(p=>`<div class="cell ${p>=MIN_OK?'ok':'bad'}">${p}%</div>`);

  show(`
    <h2>Tracking Check</h2>
    <p>Per-point hit rate (threshold per point: ${MIN_OK}%):</p>
    <div class="grid" style="grid-template-columns:repeat(5,120px)">${cells.join('')}</div>
    <p>Mean hit rate: <b>${mean}%</b> (for reference only; not the passing criterion)</p>
    <p class="muted">${passAll ? 'Passed: press Space to continue.' : 'Not passed: press Space to recalibrate (5-point).'}</p>
  `);
  await awaitSpace();

  return {acc, mean, passAll};
}

async function quickFivePointValidation(){
  showMidWhyIntro();
  await awaitSpace();

  showCalibIntro5First();
  await new Promise(r=>document.getElementById('calStart5').onclick=r);
  await warmupCameraAndPreview();
  await calibrateFivePointsMouse();

  await warmupCameraAndPreview();
  let res = await runFiveValidation();

  while (!res.passAll){
    showCalibIntro5Retry();
    await new Promise(r=>document.getElementById('calRetry5').onclick=r);
    await warmupCameraAndPreview();
    await calibrateFivePointsMouse();

    await warmupCameraAndPreview();
    res = await runFiveValidation();
  }

  show(`<h2>Tracking Check Passed</h2><p class="muted">Press Space to continue.</p>`);
  await awaitSpace();
}

/* ===== Between groups: break ===== */
async function groupIntermission(){
  show(`
    <h2>Break</h2>
    <p>You have completed the first group. Please rest your eyes and adjust posture/lighting.</p>
    <p class="muted">Press Space to continue (a 9-point calibration will run before the second group).</p>
  `);
  await awaitSpace();
  await calibrationFlow();
}

/* — Key reminder — */
async function showKeyReminder(){
  show(`
    <h2>Key Reminder</h2>
    <div class="note" style="font-size:20px"><b>${KEYMAP.legend}</b></div>
    <p class="muted">Press Space to continue.</p>
  `);
  await awaitSpace();
}

/* — Pre-main (single page) — */
async function showPreFormalReminder(){
  show(`
    <h2>About to Start the Main Session</h2>
    <p>Please confirm your key mapping:</p>
    <div class="note" style="font-size:20px"><b>${KEYMAP.legend}</b></div>
    <p class="muted">Press Space to begin preparing.</p>
  `);
  await awaitSpace();
}

/* ===================== Trial presentation ===================== */
function boxesHTML({gain, loss, gainLeft, colorGain, colorLoss, showLegend=false}){
  const leftX  = `calc(50vw - ${offsetPx()}px)`, rightX = `calc(50vw + ${offsetPx()}px)`;
  const g = `<div id="gainBox" class="box" style="left:${gainLeft?leftX:rightX}; color:${colorGain}">+$${gain}</div>`;
  const l = `<div id="lossBox" class="box" style="left:${gainLeft?rightX:leftX}; color:${colorLoss}">-$${loss}</div>`;
  return `<div class="arena"><div class="stage">${g}${l}</div></div>${keyLegendHTML(showLegend)}`;
}

/* ===================== Data & saving ===================== */
const logs = [];
let trialCounter = 0;

async function saveToServer(payload){
  const q = `?PROLIFIC_PID=${encodeURIComponent(getQS('PROLIFIC_PID'))}`
          + `&STUDY_ID=${encodeURIComponent(getQS('STUDY_ID'))}`
          + `&SESSION_ID=${encodeURIComponent(getQS('SESSION_ID'))}`;
  try{
    const r = await fetch('/save'+q, {
      method:'POST',
      headers:{'Content-Type':'application/json'},
      body: JSON.stringify(payload)
    });
    return r.ok;
  }catch(e){
    console.warn('save failed', e);
    return false;
  }
}

/* ===================== Single round (with markers only for main session) ===================== */
async function runTrial({group, gain, loss, includeInPayoff=true}){
  const t_trial_start = includeInPayoff ? performance.now() : null;

  // Fixation "+"
  showCenter(`<div class="fix">+</div>`);
  const t_fix_on = includeInPayoff ? performance.now() : null;
  await sleep(randBetween(2000,4000));

  // Stimuli
  const gainLeft = Math.random()<0.5;
  const colorGain = PARTICIPANT_GAIN_BLUE ? BLUE : GREEN;
  const colorLoss = PARTICIPANT_GAIN_BLUE ? GREEN : BLUE;

  const trial_id = includeInPayoff ? (++trialCounter) : null;

  showCenter(boxesHTML({gain, loss, gainLeft, colorGain, colorLoss, showLegend: !includeInPayoff}));
  const gBox=document.getElementById('gainBox')?.getBoundingClientRect();
  const lBox=document.getElementById('lossBox')?.getBoundingClientRect();
  const t_stim_on = includeInPayoff ? performance.now() : null;

  // Gaze sampling: ONLY for main session
  const gaze=[]; let sampling=null;
  if (WG_READY && includeInPayoff){
    if (SHOW_GAZE_DOT_TASK) gazeDot.style.display='block'; else gazeDot.style.display='none';
    sampling=setInterval(async ()=>{
      const p=await webgazer.getCurrentPrediction();
      if(p){
        const now = performance.now();
        gaze.push({t: now, t_rel: Math.round(now - t_stim_on), x:p.x, y:p.y});
        if (SHOW_GAZE_DOT_TASK){ gazeDot.style.left=p.x+'px'; gazeDot.style.top=p.y+'px'; }
      }
    },16);
  }

  // Key response
  const choice = await new Promise(resolve=>{
    function onKey(e){ if(DECISION_KEYS.has(e.key)){ window.removeEventListener('keydown', onKey); resolve(e.key.toLowerCase()); } }
    window.addEventListener('keydown', onKey);
  });
  const t_key = includeInPayoff ? performance.now() : null;
  const rt = includeInPayoff ? (t_key - t_stim_on) : null;

  if(sampling) clearInterval(sampling);
  gazeDot.style.display='none';
  const accepted=(choice===KEYMAP.accept);

  if (includeInPayoff){
    logs.push({
      phase: 'decision',
      trial_id, group, gain, loss,
      gain_left:gainLeft, color_gain:colorGain, color_loss:colorLoss,
      accepted, rt_ms:Math.round(rt),
      t_trial_start, t_fix_on, t_stim_on, t_key,
      gain_box_rect:gBox?{x:gBox.x,y:gBox.y,w:gBox.width,h:gBox.height}:null,
      loss_box_rect:lBox?{x:lBox.x,y:lBox.y,w:lBox.width,h:lBox.height}:null,
      webgazer_samples: WG_READY ? gaze : null,
      mapping_gain_blue: PARTICIPANT_GAIN_BLUE,
      mapping_accept_d: PARTICIPANT_ACCEPTS_WITH_D,
      accept_key: KEYMAP.accept, reject_key: KEYMAP.reject,
      prolific_pid: PROLIFIC_PID,
      px_per_deg: PX_PER_DEG
    });
  }
}

/* ===================== Practice & main ===================== */
async function runPractice(){
  while (true){
    show(`
      <h2>Practice</h2>
      <p>You will complete <b>${PRACTICE_N}</b> practice rounds (not used for payment). Keys: <b>${KEYMAP.legend}</b>.</p>
      <button class="btn" id="startPractice">Start practice</button>
    `);
    await new Promise(r=>document.getElementById('startPractice').onclick=r);

    const z=checkZoomAndSize(); if(z) alert(z);
    if(!isFullscreen()) await enterFullscreen();
    checkFsGuard();

    const practiceOrder = shuffle(practiceSet.map(x=>({...x})));
    for(const it of practiceOrder){
      await runTrial({group:'P', gain:it.gain, loss:it.loss, includeInPayoff:false});
    }

    show(`
      <h2>Practice finished</h2>
      <p>If you want to practice again, click <b>Practice again</b>. If you are ready, click <b>Proceed to main session</b>.</p>
      <button class="btn" id="redo">Practice again</button>
      <button class="btn" id="toMain">Proceed to main session</button>
    `);
    const choice = await new Promise(resolve=>{
      document.getElementById('redo').onclick = ()=>resolve('redo');
      document.getElementById('toMain').onclick = ()=>resolve('continue');
    });
    if (choice === 'redo') continue;
    if (choice === 'continue') break;
  }

  await showPreFormalReminder();
}

async function runGroup(index, list){
  show(`<h2>Group ${index}</h2><p class="muted">Press Space to begin.</p>`);
  await awaitSpace();

  const z=checkZoomAndSize(); if(z) alert(z);
  if(!isFullscreen()) await enterFullscreen();
  checkFsGuard();

  for(let i=0;i<list.length;i++){
    const it=list[i];
    await runTrial({group:index, gain:it.gain, loss:it.loss, includeInPayoff:true});

    const t = i+1;

    if (t % KEY_REMIND_INTERVAL === 0 && t !== MID_POINT_IN_BLOCK && t < list.length){
      await showKeyReminder();
      const z2=checkZoomAndSize(); if(z2) alert(z2);
      if(!isFullscreen()) await enterFullscreen();
      checkFsGuard();
    }

    if (t === MID_POINT_IN_BLOCK && t < list.length){
      await quickFivePointValidation();
      const z3=checkZoomAndSize(); if(z3) alert(z3);
      if(!isFullscreen()) await enterFullscreen();
      checkFsGuard();

      await showKeyReminder();
      const z4=checkZoomAndSize(); if(z4) alert(z4);
      if(!isFullscreen()) await enterFullscreen();
      checkFsGuard();
    }
  }
}

/* ===================== Payout & finish ===================== */
async function finishAndPayout(){
  const decidedIds = logs.filter(x=>x.phase==='decision').map(x=>x.trial_id);
  if (decidedIds.length === 0){
    show(`<h3>Payment Error</h3><p>No valid main-session rounds were found.</p>`);
    return;
  }
  const pickId=decidedIds[Math.floor(Math.random()*decidedIds.length)];
  const rec=logs.find(x=>x.trial_id===pickId);
  let coin=null, payout=START_ENDOWMENT;
  if(rec.accepted){ const win=Math.random()<0.5; coin=win?'win':'lose'; payout += win ? rec.gain : -rec.loss; }
  if (consent_record) logs.unshift({phase:'consent', ...consent_record});

  const summary = {
    prolific_pid: PROLIFIC_PID,
    mapping_gain_blue: PARTICIPANT_GAIN_BLUE,
    mapping_accept_d: PARTICIPANT_ACCEPTS_WITH_D,
    accept_key: KEYMAP.accept, reject_key: KEYMAP.reject,
    px_per_deg: PX_PER_DEG, sep_deg: SEP_DEG,
    practice_n: PRACTICE_N, group_n: [block1.length, block2.length],
    picked_trial: pickId, picked_group: rec.group,
    picked_choice: rec.accepted?'accept':'reject',
    coin, start_endowment: START_ENDOWMENT, payout
  };
  const payload = { summary, rounds: logs };
  saveToServer(payload);

  show(`
    <h3>Payment Result</h3>
    <p>Selected round: #${rec.trial_id} (Group ${rec.group}); your choice: <b>${rec.accepted?'Accept':'Reject'}</b></p>
    <p>${rec.accepted ? (coin==='win'?`Random outcome: <b>Win</b> (+${rec.gain})`:`Random outcome: <b>Loss</b> (−${rec.loss})`) : 'No random outcome (because you rejected).'}</p>
    <p>Start $${START_ENDOWMENT} → Final <b>$${payout.toFixed(2)}</b></p>
    ${PROLIFIC_RETURN_URL?`<p><a class="btn" href="${PROLIFIC_RETURN_URL}" style="cursor:pointer;">Return to Prolific</a></p>`:''}
  `);
}

/* ===================== Main ===================== */
async function main(){
  // Load webgazer (no progress bar)
  show(`<div class="wrap"><h2>System Notice</h2><p class="muted">Loading eye-tracking library… If this page takes unusually long, refresh or check your network connection.</p></div>`);
  try{
    await ensureWebgazer();
  }catch(e){
    const errBox=document.getElementById('err'); errBox.style.display='block';
    errBox.textContent = 'Failed to load WebGazer:\n' + (e && (e.stack||e.message||e));
    show('<div class="wrap"><h2>Unable to load eye-tracking library</h2><p>Details and possible fixes are shown in the bottom-left box.</p></div>');
    return;
  }

  await showWelcome();

  const consentResult = await showConsent();
  if (consentResult === 'declined') {
    show(`
      <h2>You chose not to participate</h2>
      <p class="muted">The session has been terminated. If this was accidental, refresh the page to restart.</p>
      ${PROLIFIC_RETURN_URL?`<p><a class="btn" href="${PROLIFIC_RETURN_URL}">Return to Prolific</a></p>`:''}
    `);
    try { if (window.webgazer) { await webgazer.stop(); } } catch(e) {}
    return;
  }

  await runScreenScaleCalibration();
  await showOverview();
  await showComprehensionQuiz();
  if (!isFullscreen()) await showFullscreenStep();

  // From here on, enable fullscreen guard
  fsGuardEnabled = true; checkFsGuard();

  // Initial camera enable (no progress bar; just a short message)
  await warmupCameraAndPreview();
  try { await initWebgazer(); } catch(e){}

  await calibrationFlow();

  await runPractice();

  await runGroup(1, block1);
  await groupIntermission();
  await runGroup(2, block2);

  await finishAndPayout();
}

document.addEventListener('DOMContentLoaded', main);
</script>
</body>
</html>
